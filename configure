#!/usr/bin/perl
###################################################
# InspIRCd Configuration Script
#
# Copyright 2002-2008 The InspIRCd Development Team
#  http://www.inspircd.org/wiki/index.php/Credits
#
# Licensed under GPL, please see the COPYING file
# for more information
#
# $Id: configure 9498 2008-04-13 22:17:15Z w00t $
#
###################################################

BEGIN {
	require 5.8.0;
}

use strict;
use warnings FATAL => qw(all);

use Data::Dumper;
BEGIN {
	$Data::Dumper::Sortkeys = 1;
	$Data::Dumper::Useqq = 1;
};

use File::Copy ();

use Socket;
use Cwd;
use Getopt::Long;

# Utility functions for our buildsystem
use make::utilities;
use make::configure;
use make::gnutlscert;
use make::opensslcert;

###############################################################################################
#
#                                   EDITABLE VARIABLES
#
###############################################################################################

# If you wish to ignore a dependency throughout the entire core, add it here.

our @ignoredeps = (
	"inspircd_win32wrapper.h",	# windows has its own configure program
);

# If you wish for all files in the entire core to have a given dependency, insert it here.
# You should keep this to an absolute minimum to avoid rebuilds that are not neccessary.

our @immutabledeps = (
	"inspircd_config.h",		# auto re-generated by configure
	"inspircd.h",
);

###############################################################################################
#
#                                 NON-EDITABLE VARIABLES
#
###############################################################################################

# List of commands that make up 'make install' and 'make deinstall'

our $install_list = "";
our $uninstall_list = "";

# This is a list of all files in the core. Each cpp file is mapped to a shared object file,
# whos file extension is omitted (these can vary from system to system). Auto detected by
# scanning the src/*.cpp files for files containing /* $Core: */ identifiers.

our %filelist = ();

# If you wish for a file to have special dependencies in the makefile, add an entry here.
# Auto populated by /* $ExtraDeps: */ instruction

our %specialdeps = ();

# If you wish for a file to have extra make lines (in between the compile and link steps)
# then insert them here.
# Auto populated by /* $ExtraBuild: */ instruction
        
our %extrabuildlines = ();

# If you wish for a file to be linked against extra objects or arctives, insert them here.
# Auto populated by /* $ExtraObjects: */ instruction

our %extraobjects = ();

# If you wish to compile extra cpp sources into an object, define them here.
# NOTE: Certain cpp files such as the socket engines have a value auto calculated
# for this table so that their derived class is built.
# Auto populated by /* $ExtraSources: */ instruction

our %extrasources = ();

our ($opt_use_gnutls, $opt_rebuild, $opt_use_openssl, $opt_nointeractive, $opt_nick_length,
    $opt_chan_length, $opt_ports, $opt_epoll, $opt_kqueue, $opt_noports,
    $opt_noepoll, $opt_nokqueue, $opt_disablerpath, $opt_ipv6, $opt_ipv6links,
    $opt_noipv6links, $opt_ident, $opt_quit, $opt_topic, $opt_maxbuf, $opt_kick,
    $opt_gecos, $opt_away, $opt_modes, $opt_disable_debug, $opt_maxchans,
    $opt_opermaxchans, $opt_maxclients, $fd_scan_fail);

our ($opt_cc, $opt_base_dir, $opt_config_dir, $opt_module_dir, $opt_binary_dir,
    $opt_library_dir);

sub list_extras ();

sub enable_extras (@);

sub disable_extras (@);

my @opt_enableextras;
my @opt_disableextras;

GetOptions (
	'enable-gnutls' => \$opt_use_gnutls,
	'rebuild' => \$opt_rebuild,
	'enable-openssl' => \$opt_use_openssl,
	'disable-interactive' => \$opt_nointeractive,
	'with-max-clients=i' => \$opt_maxclients,
	'with-nick-length=i' => \$opt_nick_length,
	'with-channel-length=i' => \$opt_chan_length,
	'enable-ports' => \$opt_ports,
	'enable-epoll' => \$opt_epoll,
	'enable-kqueue' => \$opt_kqueue,
	'disable-ports' => \$opt_noports,
	'disable-epoll' => \$opt_noepoll,
	'disable-kqueue' => \$opt_nokqueue,
	'disable-rpath' => \$opt_disablerpath,
	'enable-ipv6' => \$opt_ipv6,
	'enable-remote-ipv6' => \$opt_ipv6links,
	'disable-remote-ipv6' => \$opt_noipv6links,
	'with-cc=s' => \$opt_cc,
	'with-ident-length=i' => \$opt_ident,
	'with-quit-length=i' => \$opt_quit,
	'with-topic-length=i' => \$opt_topic,
	'with-maxbuf=i' => \$opt_maxbuf,
	'with-kick-length=i' => \$opt_kick,
	'with-gecos-length=i' => \$opt_gecos,
	'with-away-length=i' => \$opt_away,
	'with-max-modes=i' => \$opt_modes,
	'prefix=s' => \$opt_base_dir,
	'config-dir=s' => \$opt_config_dir,
	'module-dir=s' => \$opt_module_dir,
	'binary-dir=s' => \$opt_binary_dir,
	'library-dir=s' => \$opt_library_dir,
	'disable-debuginfo' => sub { $opt_disable_debug = 1 },
	'help'	=> sub { showhelp(); },
	'modupdate' => sub { modupdate(); },
	'update' => sub { update(); },
	'svnupdate' => sub { svnupdate(); },
	'clean' => sub { clean(); },
	'list-extras' => sub { list_extras; exit 0; }, # This, --enable-extras, and --disable-extras are for non-interactive managing.
	'enable-extras=s@' => \@opt_enableextras, # ^
	'disable-extras=s@' => \@opt_disableextras, # ^
);

if (scalar(@opt_enableextras) + scalar(@opt_disableextras) > 0) {
	@opt_enableextras = split /,/, join(',', @opt_enableextras);
	@opt_disableextras = split /,/, join(',', @opt_disableextras);
	enable_extras(@opt_enableextras);
	disable_extras(@opt_disableextras);
	list_extras;
	print "Remember: YOU are responsible for making sure any libraries needed have been installed!\n";
	print "Run $0 -modupdate after you've done this to update the makefiles.\n";
	exit 0;
}

our $non_interactive = (
	(defined $opt_library_dir) ||
	(defined $opt_base_dir) ||
	(defined $opt_config_dir) ||
	(defined $opt_module_dir) ||
	(defined $opt_base_dir) ||
	(defined $opt_binary_dir) ||
	(defined $opt_nointeractive) ||
	(defined $opt_maxclients) ||
	(defined $opt_away) ||
	(defined $opt_gecos) ||
	(defined $opt_kick) ||
	(defined $opt_modes) ||
	(defined $opt_topic) ||
	(defined $opt_quit) ||
	(defined $opt_ident) ||
	(defined $opt_cc) ||
	(defined $opt_ipv6) ||
	(defined $opt_ipv6links) ||
	(defined $opt_noipv6links) ||
	(defined $opt_kqueue) ||
	(defined $opt_epoll) ||
	(defined $opt_ports) ||
	(defined $opt_maxchans) ||
	(defined $opt_opermaxchans) ||
	(defined $opt_chan_length) ||
	(defined $opt_nick_length) ||
	(defined $opt_use_openssl) ||
	(defined $opt_nokqueue) ||
	(defined $opt_noepoll) ||
	(defined $opt_noports) ||
	(defined $opt_maxbuf) ||
	(defined $opt_use_gnutls)
);
our $interactive = !$non_interactive;

chomp(our $topdir = getcwd());
our $this = resolve_directory($topdir);						# PWD, Regardless.
our @modlist = ();							  		# Declare for Module List..
our %config = ();						   			# Initiate Configuration Hash..
$config{ME}		 = resolve_directory($topdir);				# Present Working Directory

$config{BASE_DIR}	   = $config{ME};

if (defined $opt_base_dir)
{
	$config{BASE_DIR} = $opt_base_dir;
}

$config{CONFIG_DIR}	 = resolve_directory($config{BASE_DIR}."/conf");	# Configuration Directory
$config{MODULE_DIR}	 = resolve_directory($config{BASE_DIR}."/modules");	# Modules Directory
$config{BINARY_DIR}	 = resolve_directory($config{BASE_DIR}."/bin");		# Binary Directory
$config{LIBRARY_DIR}	= resolve_directory($config{BASE_DIR}."/lib");		# Library Directory

if (defined $opt_config_dir)
{
	$config{CONFIG_DIR} = $opt_config_dir;
}
if (defined $opt_module_dir)
{
	$config{MODULE_DIR} = $opt_module_dir;
}
if (defined $opt_binary_dir)
{
	$config{BINARY_DIR} = $opt_binary_dir;
}
if (defined $opt_library_dir)
{
	$config{LIBRARY_DIR} = $opt_library_dir;
}
chomp($config{HAS_GNUTLS}   = `libgnutls-config --version 2>/dev/null | cut -c 1,2,3`); # GNUTLS Version.
chomp($config{HAS_OPENSSL}  = `pkg-config --modversion openssl 2>/dev/null`);		# Openssl version
chomp(our $gnutls_ver = $config{HAS_GNUTLS});
chomp(our $openssl_ver = $config{HAS_OPENSSL});
$config{USE_GNUTLS}	    = "n";
if (defined $opt_use_gnutls)
{
	$config{USE_GNUTLS} = "y";					# Use gnutls.
}
$config{USE_OPENSSL}	= "n";						# Use openssl.
if (defined $opt_use_openssl)
{
	$config{USE_OPENSSL} = "y";
}

# no, let's not change these.
$config{OPTIMITEMP}	 = "0";			      			# Default Optimisation Value
if (!defined $opt_disable_debug)
{
	$config{OPTIMISATI}	 = "-g1";			     	# Optimisation Flag
}
else
{
	$config{OPTIMISATI}	 = "-O2";				# DEBUGGING OFF!
}

$config{NICK_LENGT}	 = "31";			     		# Default Nick Length
if (defined $opt_nick_length)
{
	$config{NICK_LENGT} = $opt_nick_length;
}
$config{CHAN_LENGT}	 = "64";			     		# Default Channel Name Length
if (defined $opt_chan_length)
{
	$config{CHAN_LENGT} = $opt_chan_length;
}
$config{MAXI_MODES}	 = "20";			     		# Default Max. Number of Modes set at once.
if (defined $opt_modes)
{
	$config{MAXI_MODES} = $opt_modes;
}
$config{HAS_STRLCPY}	= "false";			  		# strlcpy Check.
$config{HAS_STDINT}	 = "false";					# stdint.h check
$config{USE_KQUEUE}	 = "y";						# kqueue enabled
if (defined $opt_kqueue)
{
	$config{USE_KQUEUE} = "y";
}
if (defined $opt_nokqueue)
{
	$config{USE_KQUEUE} = "n";
}
$config{USE_EPOLL}	  = "y";					# epoll enabled
if (defined $opt_epoll)
{
	$config{USE_EPOLL} = "y";
}
if (defined $opt_noepoll)
{
	$config{USE_EPOLL} = "n";
}
$config{USE_PORTS}	  = "y";					# epoll enabled
if (defined $opt_ports)
{
	$config{USE_PORTS} = "y";
}
if (defined $opt_noports)
{
	$config{USE_PORTS} = "n";
}
$config{IPV6}	       = "n";						# IPv6 support (experimental)
if (defined $opt_ipv6)
{
	$config{IPV6} = "y";
}
$config{SUPPORT_IP6LINKS}   = "y";					# IPv4 supporting IPv6 links (experimental)
if (defined $opt_ipv6links)
{
	$config{SUPPORT_IP6LINKS} = "y";
}
if (defined $opt_noipv6links)
{
	$config{SUPPORT_IP6LINKS} = "n";
}

chomp($config{MAX_CLIENT_T} = `sh -c \"ulimit -n\"`);	   		# FD Limit
chomp($config{MAX_DESCRIPTORS} = `sh -c \"ulimit -n\"`);		# Hard FD Limit
chomp($config{GCCVER}       = `g++ -dumpversion | cut -c 1`);   	# Major GCC Version
$config{_SOMAXCONN} = SOMAXCONN;					# Max connections in accept queue
$config{OSNAME}       	    = $^O;			      		# Operating System Name
$config{IS_DARWIN}	  = "NO";					# Is OSX?
$config{STARTSCRIPT}	  = "hottpd";			# start script?
$config{DESTINATION}	  = "BASE";				# Is target path.
$config{EXTRA_DIR}	  = "";						# Is empty.
if ($config{OSNAME} =~ /darwin/i)
{
	$config{IS_DARWIN} = "YES";
	$config{STARTSCRIPT}	  = "org.hottpd.plist";		# start script for OSX.
	$config{DESTINATION}	  = "LAUNCHDPATH";				# Is OSX target.
	$config{EXTRA_DIR}	    = " launchd_dir";				# Is OSX specific path.
}
$config{CC} 		    = "g++";						# C++ compiler
if (defined $opt_cc)
{
	$config{CC} = $opt_cc;
}
our $exec = $config{CC} . " -dumpversion | cut -c 1";
chomp($config{GCCVER}		= `$exec`);				# Major GCC Version
$config{MAKEORDER}		= "ircd mods";				# build order
$config{MAX_IDENT}		= "12";					# max ident size
$config{MAX_QUIT}		= "255";				# max quit message size
$config{MAX_TOPIC}		= "307";				# max topic size
$config{MAX_KICK}		= "255";				# max kick message size
$config{MAX_GECOS}		= "128";				# max GECOS size
$config{MAX_AWAY}		= "200";				# max AWAY size
$config{MAXBUF}			= "512";				# Max buffer size
if (defined $opt_ident)
{
	$config{MAX_IDENT} = $opt_ident;
}
if (defined $opt_quit)
{
	$config{MAX_QUIT} = $opt_quit;
}
if (defined $opt_topic)
{
	$config{MAX_TOPIC} = $opt_topic;
}
if (defined $opt_kick)
{
	$config{MAX_KICK} = $opt_kick;
}
if (defined $opt_gecos)
{
	$config{MAX_GECOS} = $opt_gecos;
}
if (defined $opt_away)
{
	$config{MAX_AWAY} = $opt_away;
}

if ($config{HAS_OPENSSL} =~ /^([-[:digit:].]+)([a-z])?(\-[a-z][0-9])?$/) {
	$config{HAS_OPENSSL} = $1;
} else {
	$config{HAS_OPENSSL} = "";
}

if ($config{GCCVER} eq "") {
	print $config{CC} . " was not found! You require g++ (the GNU C++ compiler, part of GCC) to build hottpd!\n";
	exit;
}

if (!$config{MAX_CLIENT_T}) { 
	$config{MAX_CLIENT_T} = 1024;				 # Set a reasonable 'Default'
	$fd_scan_fail = "true";				       # Used Later
}

# Get and Set some important vars..
getmodules();

sub clean
{
	unlink(".config.cache");
}

our ($has_epoll, $has_ports, $has_kqueue) = (0, 0, 0);

sub update
{
	eval {
		chomp($topdir = getcwd());
		$this = resolve_directory($topdir);					     # PWD, Regardless.
		getmodules();
		# Does the cache file exist?
		if (!getcache()) {
			# No, No it doesn't.. *BASH*
			print "You have not run ./configure before. Please do this before trying to run the update script.\n";
			exit 0;
		} else {
			# We've Loaded the cache file and all our variables..
			print "Updating files...\n";
			getosflags();
			if (defined($opt_disable_debug) && $opt_disable_debug == 1)
			{
				print "Disabling debug information (-g).\n";
				$config{OPTIMISATI} = "";
				getosflags();
			}
			$has_epoll = $config{HAS_EPOLL};
			$has_ports = $config{HAS_PORTS};
			$has_kqueue = $config{HAS_KQUEUE};
			writefiles(1);
			makecache();
			print "Complete.\n";
			exit;
		}
	};
	if ($@)
	{
		print "Configure update failed: $@\n";
	}
	exit;
}

sub modupdate
{
	eval {
		chomp($topdir = getcwd());
		$this = resolve_directory($topdir);					     # PWD, Regardless.
		getmodules();
		# Does the cache file exist?
		if (!getcache()) {
			# No, No it doesn't.. *BASH*
			print "You have not run ./configure before. Please do this before trying to run the update script.\n";
			exit 0;
		} else {
			# We've Loaded the cache file and all our variables..
			print "Updating files...\n";
			getosflags();
			$has_epoll = $config{HAS_EPOLL};
			$has_ports = $config{HAS_PORTS};
			$has_kqueue = $config{HAS_KQUEUE};
			writefiles(0);
			makecache();
			print "Complete.\n";
			exit;
		}
	};
	if ($@)
	{
		print "Module update failed: $@\n";
	}
	exit;
}



sub svnupdate
{
	my $fail = 0;
	open(FH,"<.svn/entries") or $fail = 1;
	if ($fail) {
		print "This is not an SVN copy of hottpd.\n";
		exit;
	}
	else
	{
		close(FH);
	}
	open my $fd, "-|", "svn update";
	my $configurechanged = 0; # Needs ./configure -update
	my $coredirchanged = 0; # Needs ./configure -update
	my $moduledirchanged = 0; # Needs ./configure -modupdate
	my $rootincchanged = 0;
	my @conflicted = ();
	while (defined(my $line = <$fd>))
	{
		my ($action, $file);
		print $line;
		$line =~ m/^([ADUCG])\s+(.*)$/ or next;
		($action, $file) = ($1, $2);
		if ($action eq "C")
		{
			push @conflicted, $file;
			if ($file eq "configure")
			{
				$configurechanged = 1;
			}
			elsif ($file =~ m#^src/modules#)
			{
				$moduledirchanged = 1;
			}
			elsif ($file =~ m#^src/#)
			{
				$coredirchanged = 1;
			}
			elsif ($file =~ m/^\..*\.inc$/)
			{
				$rootincchanged = 1;
			}
		}
		elsif ($action eq "U" || $action eq "G")
		{
			if ($file eq "configure")
			{
				$configurechanged = 1;
			}
			elsif ($file =~ m/^\..*\.inc$/)
			{
				$rootincchanged = 1;
			}
		}
		elsif ($action eq "A" || $action eq "D")
		{
			if ($file =~ m#^src/modules#)
			{
				$moduledirchanged = 1;
			}
			elsif ($file =~ m#^src/#)
			{
				$coredirchanged = 1;
			}
		}
	}
	unless (close $fd) # close() waits for exit and returns false if the command failed
	{
		if ($! == 0)
		{
			print STDERR "Problem updating from SVN, please check above for errors\n";
		}
		else
		{
			print STDERR "Failed to run SVN: $!\n";
		}
		exit 1;
	}
	if (scalar(@conflicted) > 0)
	{
		print STDERR "\e[0;33;1mERROR:\e[0m You have local modifications which conflicted with the updates from SVN\n";
		printf STDERR "Configure is not able to complete the update. Please resolve these conflicts, then run ./configure -%supdate\n", (($coredirchanged || $configurechanged) ? "" : "mod");
		print "Conflicted files: " . join ", ", @conflicted . "\n";
		exit 1;
	}
	if ($configurechanged || $coredirchanged)
	{
		system("perl configure -update");
	}
	elsif ($moduledirchanged || $rootincchanged)
	{
		system("perl configure -modupdate");
	}
	else
	{
		print "No need to update Makefiles.\n";
	}
	if (defined $opt_rebuild) {
		system("make install");
	}
	exit;
}

print "Running non-interactive configure...\n" unless $interactive;
print "Checking for cache from previous configure... ";
print ((!getcache()) ? "not found\n" : "found\n");
print "Checking operating system version... ";
print getosflags() . "\n";

if (defined $opt_maxclients)
{
	$config{MAX_CLIENT} = $opt_maxclients;
}

if (!$config{MAX_CLIENT}) { 
	# If the cache hasn't set the max clients, copy the variable of MAX_CLIENT_T, this
	# allows us to keep _T for testing purposes. (ie. "Are you sure you want to go
	# higher than the found value" :))
	$config{MAX_CLIENT} = $config{MAX_CLIENT_T};
}

printf "Checking if stdint.h exists... ";
$config{HAS_STDINT} = "true";
our $fail = 0;
open(STDINT, "</usr/include/stdint.h") or $config{HAS_STDINT} = "false";
if ($config{HAS_STDINT} eq "true") {
	close(STDINT);
}
print "yes\n" if $config{HAS_STDINT} eq "true";
print "no\n" if $config{HAS_STDINT} eq "false";

printf "Checking if strlcpy exists... ";
# Perform the strlcpy() test..
$config{HAS_STRLCPY} = "false";
$fail = 0;
open(STRLCPY, "</usr/include/string.h") or $fail = 1;
if (!$fail) {
	while (defined(my $line = <STRLCPY>)) {
		chomp($line);
		# try and find the delcaration of:
		# size_t strlcpy(...)
		if ($line =~ /size_t(\0x9|\s)+strlcpy/)	{
			$config{HAS_STRLCPY} = "true";
		}
	}
	close(STRLCPY);
}
print "yes\n" if $config{HAS_STRLCPY} eq "true";
print "no\n" if $config{HAS_STRLCPY} eq "false";

printf "Checking if kqueue exists... ";
$has_kqueue = 0;
$fail = 0;
open(KQUEUE, "</usr/include/sys/event.h") or $fail = 1;
if (!$fail) {
	while (defined(my $line = <KQUEUE>)) {
		chomp($line);
		# try and find the delcaration of:
		# int kqueue(void);
		if ($line =~ /int(\0x9|\s)+kqueue/) {
			$has_kqueue = 1;
		}
	}
	close(KQUEUE);
}
print "yes\n" if $has_kqueue == 1;
print "no\n" if $has_kqueue == 0;

printf "Checking if epoll exists... ";
$has_epoll = 0;
$fail = 0;
open(EPOLL, "</usr/include/sys/epoll.h") or $fail = 1;
if (!$fail) {
	$has_epoll = 1;
	close(EPOLL);
}
if ($has_epoll) {
	my $kernel = `uname -r`;
	chomp($kernel);
	if (($kernel =~ /^2\.0\./) || ($kernel =~ /^2\.2\./) || ($kernel =~ /^2\.4\./)) {
		$has_epoll = 0;
	}
	else
	{
		# Suggestion from nenolod, weed out odd systems which have glibc built
		# against 2.4 kernels (ick)
		my $kernel_arch = `uname -p`;
		chomp($kernel_arch);
		my $libcv = 0.0;
		my $kernelv = 0.0;
		if ($kernel_arch =~ /x86_64/) {
			open (FH,"/lib64/libc.so.6|") or $has_epoll = 0;
		}
		else {
			open (FH,"/lib/libc.so.6|") or $has_epoll = 0;
		}
		if ($has_epoll)
		{
			while (defined(my $line = <FH>))
			{
				chomp($line);
				if ($line =~ /GNU C Library .* version (.*?) /)
				{
					$libcv = $1;
					$libcv =~  /(\d+\.\d+)/;
					$libcv = $1;
				}
				elsif ($line =~ /Compiled on a Linux (.*?\..*?)\.* system/)
				{
					$kernelv = $1;
					# Fix for some retarded libc builds, strip off >> and << etc.
					$kernelv =~ /(\d+\.\d+)/;
					$kernelv = $1;
				}
			}
			close FH;
			if ($libcv < 2.3)
			{
				$has_epoll = 0;
				printf "libc too old: $libcv... ";
			}
			if ($kernelv < 2.6)
			{
				$has_epoll = 0;
				printf "libc built against older kernel $kernelv... ";
			}
		}
	}
}
print "yes\n" if $has_epoll == 1;
print "no\n" if $has_epoll == 0;

printf "Checking if Solaris I/O completion ports are available... ";
$has_ports = 0;
our $system = `uname -s`;
chomp ($system);
$has_ports = 1 if ($system eq "SunOS");

if ($has_ports) {
	my $kernel = `uname -r`;
	chomp($kernel);
	if (($kernel !~ /^5\.1./)) {
		$has_ports = 0;
	}
}
print "yes\n" if $has_ports == 1;
print "no\n" if $has_ports == 0;

$config{HAS_EPOLL} = $has_epoll;
$config{HAS_KQUEUE} = $has_kqueue; 

printf "Checking for libgnutls... ";
if (defined($config{HAS_GNUTLS}) && (($config{HAS_GNUTLS}) || ($config{HAS_GNUTLS} eq "y"))) {
	print "yes\n";
	$config{HAS_GNUTLS} = "y";
} else {
	print "no\n";
	$config{HAS_GNUTLS} = "n";
}

printf "Checking for openssl... ";
if (defined($config{HAS_OPENSSL}) && (($config{HAS_OPENSSL}) || ($config{HAS_OPENSSL} eq "y"))) {
	print "yes\n";
	$config{HAS_OPENSSL} = "y";
} else {
	print "no\n";
	$config{HAS_OPENSSL} = "n";
}

printf "Checking if you are running an ancient, unsupported OS... ";
if ($config{OSNAME} =~ /FreeBSD/i)
{
	my $version = `uname -r`;
	if ($version =~ /^4\./)
	{
		my $foundit = `ls -l /usr/local/lib/libgnugetopt* | wc -l`;
		if ($foundit > 0)
		{
			# ICKY ICKY ICK, FREEBSD 4.x! GET AN UPGRADE!
			$config{CRAQ} = "-L/usr/local/lib -lgnugetopt -DHAVE_DECL_GETOPT=1";
			print "yes\n";
		}
		else
		{
			print "\n\nERROR: You require libgnugetopt (from ports or packages) to build hottpd on FreeBSD 4.11.\n";
		}
 	}
	else
	{
		$config{CRAQ} = " ";
		print "no ($version)\n";
	}
}
else
{
	$config{CRAQ} = " ";
	print "no ($config{OSNAME})\n";
}

################################################################################
#			  BEGIN INTERACTIVE PART			      #
################################################################################

# Clear the Screen..
if ($interactive)
{
	print "\e[2J\e[0G\e[0d"; # J = Erase in Display, 2 = Entire Screen, (G, d) = Move cursor to (..,..)
	my $wholeos = $^O;

	my $rev = getrevision();
	# Display Introduction Message..
	print <<"STOP" ;
Welcome to the \e[1mhottpd\e[0m Configuration program! (\e[1minteractive mode\e[0m)
\e[1mPackage maintainers: Type ./configure --help for non-interactive help\e[0m

*** If you are unsure of any of these values, leave it blank for    ***
*** standard settings that will work, and your server will run      ***
*** using them. Please consult your IRC network admin if in doubt.  ***

Press \e[1m<RETURN>\e[0m to accept the default for any option, or enter
a new value. Please note: You will \e[1mHAVE\e[0m to read the docs
dir, otherwise you won't have a config file!

Your operating system is: \e[1;32m$config{OSNAME}\e[0m ($wholeos)
Your hottpd revision ID is \e[1;32mr$rev\e[0m
STOP
	if ($rev eq "r0") {
		print " (Non-SVN build)";
	}
	print ".\n\n";

	$config{CHANGE_COMPILER} = "n";
	print "I have detected the following compiler: \e[1;32m$config{CC}\e[0m (version \e[1;32m$config{GCCVER}.x\e[0m)\n";

	while (($config{GCCVER} < 3) || ($config{GCCVER} eq "")) {
		print "\e[1;32mIMPORTANT!\e[0m A GCC 2.x compiler has been detected, and
should NOT be used. You should probably specify a newer compiler.\n\n";
		yesno('CHANGE_COMPILER',"Do you want to change the compiler?");
		if ($config{CHANGE_COMPILER} =~ /y/i) {
			print "What command do you want to use to invoke your compiler?\n";
			print "[\e[1;32m$config{CC}\e[0m] -> ";
			chomp($config{CC} = <STDIN>);
			if ($config{CC} eq "") {
				$config{CC} = "g++";
			}
			chomp(my $foo = `$config{CC} -dumpversion | cut -c 1`);
			if ($foo ne "") {
				chomp($config{GCCVER}       = `$config{CC} -dumpversion | cut -c 1`); # we must redo these if we change compilers
				print "Queried compiler: \e[1;32m$config{CC}\e[0m (version \e[1;32m$config{GCCVER}.x\e[0m)\n";
				if ($config{GCCVER} < 3) {
					print "\e[1;32mGCC 2.x WILL NOT WORK!\e[0m. Let's try that again, shall we?\n";
				}
			}
			else {
				print "\e[1;32mWARNING!\e[0m Could not execute the compiler you specified. You may want to try again.\n";
			}
		}
	}

	print "\n";

	# Directory Settings..
	my $tmpbase = $config{BASE_DIR};
	dir_check("do you wish to install the hottpd base", "BASE_DIR");
	if ($tmpbase ne $config{BASE_DIR}) {
		$config{CONFIG_DIR}	 = resolve_directory($config{BASE_DIR}."/conf");	   # Configuration Dir
		$config{MODULE_DIR}	 = resolve_directory($config{BASE_DIR}."/modules");	# Modules Directory
		$config{BINARY_DIR}	 = resolve_directory($config{BASE_DIR}."/bin");	    # Binary Directory
		$config{LIBRARY_DIR}	= resolve_directory($config{BASE_DIR}."/lib");	    # Library Directory
	}

	dir_check("are the configuration files", "CONFIG_DIR");
	dir_check("are the modules to be compiled to", "MODULE_DIR");
	dir_check("is the IRCd binary to be placed", "BINARY_DIR");
	dir_check("are the IRCd libraries to be placed", "LIBRARY_DIR");

	if ($has_kqueue) {
		yesno('USE_KQUEUE',"You are running a BSD operating system, and kqueue\nwas detected. Would you like to enable kqueue support?\nThis is likely to increase performance.\nIf you are unsure, answer yes.\n\nEnable kqueue?");
		print "\n";
	}
	if ($has_epoll) {
		yesno('USE_EPOLL',"You are running a Linux 2.6+ operating system, and epoll\nwas detected. Would you like to enable epoll support?\nThis is likely to increase performance.\nIf you are unsure, answer yes.\n\nEnable epoll?");
		print "\n";
	}
	if ($has_ports) {
		yesno('USE_PORTS',"You are running Solaris 10.\nWould you like to enable I/O completion ports support?\nThis is likely to increase performance.\nIf you are unsure, answer yes.\n\nEnable support for I/O completion ports?");
		print "\n";
	}
	my $chose_hiperf = (($config{USE_EPOLL} eq "y") || ($config{USE_KQUEUE} eq "y") || ($config{USE_PORTS} eq "y"));
	if (!$chose_hiperf) {
		print "No high-performance socket engines are available, or you chose\n";
		print "not to enable one. Defaulting to select() engine.\n\n";
	}

	yesno('IPV6',"Would you like to build hottpd with IPv6 support?");
	print "\n";

	if ($config{IPV6} eq "y") {
		print "You have chosen to build an \e[1;32mIPV6-enabled\e[0m server.\nTo accept IPV4 users, you can still use IPV4 addresses\nin your port bindings..\n\n";
		$config{SUPPORT_IP6LINKS} = "y";
	} else {
		yesno('SUPPORT_IP6LINKS',"You have chosen to build an \e[1;32mIPV4-only\e[0m server.\nWould you like to enable support for linking to IPV6-enabled\nhottpd servers?\nIf you are using a recent operating\nsystem and are unsure, answer yes.\nIf you answer 'no' here, your hottpd server will be unable\nto parse IPV6 addresses (e.g. for CIDR bans)");
		print "\n";
	}

	if (($config{HAS_GNUTLS} eq "y") && ($config{HAS_OPENSSL} eq "y")) {
		print "I have detected both \e[1;32mGnuTLS\e[0m and \e[1;32mOpenSSL\e[0m on your system.\n";
		print "I will default to GnuTLS. If you wish to use OpenSSL\n";
		print "instead, you should enable the OpenSSL module yourself\n";
		print "by copying it from src/modules/extra to src/modules.\n\n";
		print "Detected GnuTLS version: \e[1;32m" . $gnutls_ver . "\e[0m\n";
		print "Detected OpenSSL version: \e[1;32m" . $openssl_ver . "\e[0m\n\n";
	}

	if ($config{HAS_GNUTLS} eq "y") {
		yesno('USE_GNUTLS', "Would you like to enable SSL Support?");
		if ($config{USE_GNUTLS} eq "y") {
			print "\nUsing GnuTLS SSL module.\n";
		}
	} elsif	($config{HAS_OPENSSL} eq "y") {
			yesno('USE_OPENSSL', "Would you like to enable SSL Support?");
	if ($config{USE_OPENSSL} eq "y") {
			print "\nUsing OpenSSL SSL module.\nYou will get better performance if you move to GnuTLS in the future.\n";
		}
	}
	else {
		print "\nCould not detect OpenSSL or GnuTLS. Make sure pkg-config is installed if\nyou intend to use OpenSSL, or that GnuTLS is in your path if you intend\nto use GnuTLS.\n\n";
	}

	print "\nThe following questions will ask you for various figures relating\n";
	print "To your HTTPD install. Please note that these should usually be left\n";
	print "as defaults unless you have a real reason to change them.\n\n";

	# File Descriptor Settings..
	promptnumeric("number of open files at any one time", "MAX_CLIENT_T");
	$config{MAX_CLIENT} = $config{MAX_CLIENT_T};
	$config{MAX_DESCRIPTORS} = $config{MAX_CLIENT_T};
	promptnumeric("length of nicknames", "NICK_LENGT");
	promptnumeric("length of channel names", "CHAN_LENGT");
	promptnumeric("number of mode changes in one line", "MAXI_MODES");
	promptnumeric("length of an ident (username)", "MAX_IDENT");
	promptnumeric("length of a quit message", "MAX_QUIT");
	promptnumeric("length of a channel topic", "MAX_TOPIC");
	promptnumeric("length of a kick message", "MAX_KICK");
	promptnumeric("length of a GECOS (real name)", "MAX_GECOS");
	promptnumeric("length of an away message", "MAX_AWAY");
}

dumphash();

if (($config{USE_GNUTLS} eq "y") && ($config{HAS_GNUTLS} ne "y"))
{
	print "Sorry, but i couldn't detect gnutls. Make sure gnutls-config is in your path.\n";
	exit(0);
}
if (($config{USE_OPENSSL} eq "y") && ($config{HAS_OPENSSL} ne "y"))
{
	print "Sorry, but i couldn't detect openssl. Make sure openssl is in your path.\n";
	exit(0);
}
our $failed = 0;

if ($config{USE_GNUTLS} eq "y") {
	unless (-r "src/modules/m_ssl_gnutls.cpp") {
		print "Symlinking src/modules/m_ssl_gnutls.cpp from extra/\n";
		symlink "extra/m_ssl_gnutls.cpp", "src/modules/m_ssl_gnutls.cpp" or print STDERR "Symlink failed: $!";
	}
	getmodules();
	if ($interactive)
	{
		unless (-r "$config{CONFIG_DIR}/key.pem" && -r "$config{CONFIG_DIR}/cert.pem") {
			print "SSL Certificates Not found, Generating.. \n\n
*************************************************************
* Generating the Private Key may take some time, go grab a  *
* Coffee. Even better, to generate some more entropy if it  *
* is taking a while, open another console and type du / a   *
* few times and get that HD going :) Then answer the        *
* Questions which follow. If you are unsure, just hit enter *
*************************************************************\n\n";
			$failed = make_gnutls_cert();
			if ($failed) {
				print "\n\e[1;32mCertificate generation failed!\e[0m\n\n";
			} else {
				print "\nCertificate generation complete, copying to config directory... ";
				File::Copy::move("key.pem", "$config{CONFIG_DIR}/key.pem") or print STDERR "Could not copy key.pem!\n";
				File::Copy::move("cert.pem", "$config{CONFIG_DIR}/cert.pem") or print STDERR "Could not copy cert.pem!\n";
				print "Done.\n\n";
			}
		}
		else {
			print "SSL Certificates found, skipping.\n\n";
		}
	}
	else
	{
		print "Skipping SSL certificate generation\nin non-interactive mode.\n\n";
	}
} elsif ($config{USE_OPENSSL} eq "y") {
	unless (-r "src/modules/m_ssl_openssl.cpp") {
		print "Symlinking src/modules/m_ssl_openssl.cpp from extra/\n";
		symlink "extra/m_ssl_openssl.cpp", "src/modules/m_ssl_openssl.cpp" or print STDERR "Symlink failed: $!";
	}
	getmodules();
	$failed = 0;
	if ($interactive)
	{
		unless (-r "$config{CONFIG_DIR}/key.pem" && -r "$config{CONFIG_DIR}/cert.pem") {
			print "SSL Certificates Not found, Generating.. \n\n
*************************************************************
* Generating the certificates may take some time, go grab a *
* coffee, or something.	                                    *
*************************************************************\n\n";
			make_openssl_cert();
			print "\nCertificate generation complete, copying to config directory... ";
			File::Copy::move("key.pem", "$config{CONFIG_DIR}/key.pem") or print STDERR "Could not copy key.pem!\n";
			File::Copy::move("cert.pem", "$config{CONFIG_DIR}/cert.pem") or print STDERR "Could not copy cert.pem!\n";
			File::Copy::move("dhparams.pem", "$config{CONFIG_DIR}/dhparams.pem") or print STDERR "Could not copy dhparams.pem!\n";
			print "Done.\n\n";
		} else {
			print "SSL Certificates found, skipping.\n\n"
		}
	}
	else
	{
		print "Skipping SSL certificate generation\nin non-interactive mode.\n\n";
	}
}
if (($config{USE_GNUTLS} eq "n") && ($config{USE_OPENSSL} eq "n")) {
	print "Skipping SSL Certificate generation, SSL support is not available.\n\n";
}

getosflags();
writefiles(1);
makecache();

print "\n\n";
print "To build your server with these settings, please type '\e[1;32m$config{MAKEPROG}\e[0m' now.\n";
if (($config{USE_GNUTLS} eq "y") || ($config{USE_OPENSSL} eq "y")) {
	print "Please note: for \e[1;32mSSL support\e[0m you will need to load required\n";
	print "modules in your config. This configure script has added those modules to the\n";
	print "build process. For more info please refer to:\n";
	print "\e[1;32mhttp://www.inspircd.org/wiki/Installation_From_Tarball\e[0m\n";
}
print "*** \e[1;32mRemember to edit your configuration files!!!\e[0m ***\n\n\n";
if (($config{OSNAME} eq "OpenBSD") && ($config{CC} ne "eg++")) {
	print "\e[1;32mWARNING!\e[0m You are running OpenBSD but you are using the base gcc package\nrather than eg++. This compile will most likely fail, but i'm letting you\ngo ahead with it anyway, just in case i'm wrong :-)\n";
}

if ($config{GCCVER} < "3") {
	print <<FOO2;
\e[1;32mWARNING!\e[0m You are attempting to compile hottpd on GCC 2.x!
GCC 2.x series compilers only had partial (read as broken) C++ support, and
your compile will most likely fail horribly! If you have any problems, do NOT
report them to the bugtracker or forums without first upgrading your compiler
to a newer 3.x or 4.x (or whatever is available currently) version.
FOO2
}

################################################################################
#			      HELPER FUNCTIONS				#
################################################################################
sub getcache {
	# Retrieves the .config.cache file, and loads values into the main config hash.
	open(CACHE, ".config.cache") or return 0;
	while (<CACHE>) {
		chomp;
		# Ignore Blank lines, and comments..
		next if /^\s*$/;
		next if /^\s*#/;
		my ($key, $value) = split("=", $_, 2);
		$value =~ /^\"(.*)\"$/;
		# Do something with data here!
		$config{$key} = $1;
	}
	close(CACHE);
	return 1;
}

sub makecache {
	# Dump the contents of %config
	print "Writing \e[1;32mcache file\e[0m for future ./configures ...\n";
	open(FILEHANDLE, ">.config.cache");
	foreach my $key (keys %config) {
		print FILEHANDLE "$key=\"$config{$key}\"\n";
	}
	close(FILEHANDLE);
}

sub dir_check {
	my ($desc, $hash_key) = @_;
	my $complete = 0;
	while (!$complete) {
		print "In what directory $desc?\n";
		print "[\e[1;32m$config{$hash_key}\e[0m] -> ";
		chomp(my $var = <STDIN>);
		if ($var eq "") {
			$var = $config{$hash_key};
		}
		if ($var =~ /^\~\/(.+)$/) {
			# Convert it to a full path..
			$var = resolve_directory($ENV{HOME} . "/" . $1);
		}
		elsif ((($config{OSNAME} =~ /MINGW32/i) and ($var !~ /^[A-Z]{1}:\\.*/)) and (substr($var,0,1) ne "/"))
		{
			# Assume relative Path was given.. fill in the rest.
			$var = $this . "/$var";
		}
		
		$var = resolve_directory($var); 
		if (! -e $var) {
			print "$var does not exist. Create it?\n[\e[1;32my\e[0m] ";
			chomp(my $tmp = <STDIN>);
			if (($tmp eq "") || ($tmp =~ /^y/i)) {
				# Attempt to Create the Dir..
				my $chk = eval {
					use File::Path ();
					File::Path::mkpath($var, 0, 0777);
					1;
				};
				unless (defined($chk) && -d $var) {
					print "Unable to create directory. ($var)\n\n";
					# Restart Loop..
					next;
				}
			} else {
				# They said they don't want to create, and we can't install there.
				print "\n\n";
				next;
			}
		} else {
			if (!is_dir($var)) {
				# Target exists, but is not a directory.
				print "File $var exists, but is not a directory.\n\n";
				next;
			}
		}
		# Either Dir Exists, or was created fine.
		$config{$hash_key} = $var;
		$complete = 1;
		print "\n";
	}
}

our $SHARED = "";

sub getosflags {

	# Beware: Linux sets it's own cflags below for some retarded reason
	$config{LDLIBS} = "-pthread -lstdc++";
	$config{FLAGS}  = "-fPIC -Woverloaded-virtual -Wshadow -Wformat=2 -Wmissing-format-attribute -Wall $config{OPTIMISATI}";
	$config{DEVELOPER} = "-fPIC -Woverloaded-virtual -Wshadow -Wall -Wformat=2 -Wmissing-format-attribute -g";
	$SHARED = "-Wl,--rpath -Wl,$config{LIBRARY_DIR} -shared" unless defined $opt_disablerpath;
	$config{MAKEPROG} = "make";

	if ($config{OSNAME} =~ /darwin/i) {
		$config{FLAGS}  = "-DDARWIN -frtti -fPIC -Wall $config{OPTIMISATI}";
		$SHARED = "-bundle -twolevel_namespace -undefined dynamic_lookup";
		$config{LDLIBS} = "-ldl -pthread -lstdc++";
	}

	if ($config{OSNAME} =~ /OpenBSD/i) {
		$config{MAKEPROG} = "gmake";
		$config{LDLIBS} = $config{LDLIBS} . " -lunwind";
		chomp(my $foo = `eg++ -dumpversion | cut -c 1`);
		# theyre running the package version of gcc (eg++)... detect it and set up its version numbers.
		# if theyre not running this, configure lets the build continue but they probably wont manage to
		# compile as this standard version is 2.95.3!
		if ($foo ne "") {
			$config{CC} = "eg++";
			chomp($config{GCCVER}       = `eg++ -dumpversion | cut -c 1`); # we must redo these if we change the compiler path
		}
		return "OpenBSD";
	}

	if ($config{OSNAME} =~ /Linux/i) {
		$config{LDLIBS} = "-ldl -lstdc++ -pthread";
#		$config{FLAGS}  = "-fPIC -Woverloaded-virtual -Wshadow -Wall $config{OPTIMISATI}";
		$config{FLAGS}  .= " " . $ENV{CXXFLAGS} if exists($ENV{CXXFLAGS});
		$config{LDLIBS} .= " " . $ENV{LDLIBS} if exists($ENV{LDLIBS});
		$config{MAKEPROG} = "make";
	}

	if ($config{OSNAME} =~ /FreeBSD/i) {
		$config{FLAGS}  .= " " . $ENV{CXXFLAGS} if exists($ENV{CXXFLAGS});
		$config{LDLIBS} .= " " . $ENV{LDLIBS} if exists($ENV{LDLIBS});
	}

	if ($config{OSNAME} =~ /SunOS/i or $config{OSNAME} =~ /solaris/i)
	{
		# solaris/sunos needs these
		# socket = bsd sockets api
		# nsl = dns stuff
		# rt = POSIX realtime extensions
		# resolv = inet_aton only (why isnt this in nsl?!)
		$config{MAKEPROG} = "gmake";
		$config{LDLIBS} .= " -lsocket -lnsl -lrt -lresolv -pthread";
		return "Solaris";
	}
	
	if($config{OSNAME} =~ /MINGW32/i)
	{
		# All code is position-independent on windows
		$config{FLAGS} =~ s/-fPIC //;
		return "MinGW";
	}

	return $config{OSNAME};
}

my ($mliflags, $mfrules, $mobjs, $mfcount) = ("", "", "", 0);

sub writefiles {
	my($writeheader) = @_;
	my $se = "";
	# First File.. inspircd_config.h
	chomp(my $incos = `uname -n -s -r`);
	chomp(my $version = `sh src/version.sh`);
	chomp(my $revision2 = getrevision());
	if ($writeheader == 1)
	{
		print "Writing \e[1;32minspircd_config.h\e[0m\n";
		open(FILEHANDLE, ">include/inspircd_config.h");
		my $NL = $config{NICK_LENGT}+1;
		my $CL = $config{CHAN_LENGT}+1;
		print FILEHANDLE <<EOF;
/* Auto generated by configure, do not modify! */
#ifndef __CONFIGURATION_AUTO__
#define __CONFIGURATION_AUTO__

/* this is for windows support. */
#define CoreExport /**/
#define DllExport /**/

#define CONFIG_FILE "$config{CONFIG_DIR}/hottpd.conf"
#define MOD_PATH "$config{MODULE_DIR}"
#define VERSION "$version"
#define REVISION "$revision2"
#define SOMAXCONN_S "$config{_SOMAXCONN}"
#define MAXCLIENTS $config{MAX_CLIENT}
#define MAXCLIENTS_S "$config{MAX_CLIENT}"
#define MAX_DESCRIPTORS $config{MAX_DESCRIPTORS}
#define NICKMAX $NL
#define CHANMAX $CL
#define MAXMODES $config{MAXI_MODES}
#define IDENTMAX $config{MAX_IDENT}
#define MAXQUIT $config{MAX_QUIT}
#define MAXTOPIC $config{MAX_TOPIC}
#define MAXKICK $config{MAX_KICK}
#define MAXGECOS $config{MAX_GECOS}
#define MAXAWAY $config{MAX_AWAY}
#define OPTIMISATION $config{OPTIMITEMP}
#define LIBRARYDIR "$config{LIBRARY_DIR}"
#define SYSTEM "$incos"

EOF
print FILEHANDLE "#define MAXBUF " . ($config{MAXBUF}+2) . "\n";

		if ($config{OSNAME} =~ /SunOS/i) {
			print FILEHANDLE "#define IS_SOLARIS\n";
		}
		if ($config{OSNAME} =~ /MINGW32/i) {
			print FILEHANDLE "#define IS_MINGW\n";
		}
		if ($config{GCCVER} >= 3) {
			print FILEHANDLE "#define GCC3\n";
		}
		if ($config{HAS_STRLCPY} eq "true") {
			print FILEHANDLE "#define HAS_STRLCPY\n";
		}
		if ($config{HAS_STDINT} eq "true") {
			print FILEHANDLE "#define HAS_STDINT\n";
		}
		if ($config{IPV6} =~ /y/i) {
			print FILEHANDLE "#define IPV6\n";
		}
		if ($config{SUPPORT_IP6LINKS} =~ /y/i) {
			print FILEHANDLE "#define SUPPORT_IP6LINKS\n";
		}
		my $use_hiperf = 0;
		if (($has_kqueue) && ($config{USE_KQUEUE} eq "y")) {
			print FILEHANDLE "#define USE_KQUEUE\n";
			$se = "socketengine_kqueue";
			$use_hiperf = 1;
		}
		if (($has_epoll) && ($config{USE_EPOLL} eq "y")) {
			print FILEHANDLE "#define USE_EPOLL\n";
			$se = "socketengine_epoll";
			$use_hiperf = 1;
		}
		if (($has_ports) && ($config{USE_PORTS} eq "y")) {
			print FILEHANDLE "#define USE_PORTS\n";
			$se = "socketengine_ports";
			$use_hiperf = 1;
		}
		# user didn't choose either epoll or select for their OS.
		# default them to USE_SELECT (ewwy puke puke)
		if (!$use_hiperf) {
			print FILEHANDLE "#define USE_SELECT\n";
			$se = "socketengine_select";
		}
		# print FILEHANDLE "\n#include \"threadengines/threadengine_pthread.h\"\n\n#endif\n";
		print FILEHANDLE "\n\n#endif\n";
		close(FILEHANDLE);
	}

	if ($writeheader)
	{
		open(FILEHANDLE, ">include/inspircd_se_config.h");
		print FILEHANDLE <<EOF;
/* Auto generated by configure, do not modify or commit to svn! */
#ifndef __CONFIGURATION_SOCKETENGINE__
#define __CONFIGURATION_SOCKETENGINE__

#include "socketengines/$se.h"

#endif
EOF
		close(FILEHANDLE);
	}


	# Create a Modules List..
	my $modules = "";
	foreach my $i (@modlist)
	{
		$modules .= "m_".$i.".so ";
	}
	chomp($modules);   # Remove Redundant whitespace..

	opendir(DIRHANDLE, "src/modules");
	foreach my $name (sort readdir(DIRHANDLE)) {
		if ($name =~ /^m_(.+?)$/) {
			if (defined(opendir(MDIRHANDLE, "src/modules/$name"))) {
				closedir(MDIRHANDLE);
				$modules .= "$name.so ";
				$uninstall_list = $uninstall_list . "	-rm \$(MODULES)/$name.so\n";
			}
		}
	}
	closedir(DIRHANDLE);


	# Write all .in files.
	my $tmp = "";
	my $file = "";
	my $exe = "hottpd";

	# Do this once here, and cache it in the .*.inc files,
	# rather than attempting to read src/version.sh from
	# compiled code -- we might not have the source to hand.
	# Fix for bug#177 by Brain.

	chomp($version = `sh ./src/version.sh`);
	chomp(my $revision = getrevision());
	$version = "$version(r$revision)";

	# We can actually parse any file starting with . and ending with .inc,
	# but right now we only parse .hottpd.inc to form './hottpd'

        print "Writing \e[1;32mMakefiles\e[0m\n";
	write_dynamic_modules_makefile();
	write_dynamic_makefile();

	opendir(DIRHANDLE, $this);

	foreach my $name (sort readdir(DIRHANDLE)) {
		if ($name =~ /^\.(.+)\.inc$/) {
			$file = $1;

			# Bug #353, omit this on non-darwin
			next if (($config{OSNAME} !~ /darwin/) && ($file eq "org.hottpd.plist"));

			# All .name.inc files need parsing!
			$tmp = "";
			open(FILEHANDLE, ".$file.inc") or die ("Can't open .$file.inc");
			while (<FILEHANDLE>) {
				$tmp .= $_;
			}
			close(FILEHANDLE);

			print "Writing \e[1;32m$file\e[0m ...\n";
			$tmp =~ s/\@CC\@/$config{CC}/ if defined $config{CC};
			$tmp =~ s/\@MAKEPROG\@/$config{MAKEPROG}/ if defined $config{MAKEPROG};
			$tmp =~ s/\@FLAGS\@/$config{FLAGS}/ if defined $config{FLAGS};
			$tmp =~ s/\@DEVELOPER\@/$config{DEVELOPER}/ if defined $config{DEVELOPER};
			$tmp =~ s/\@LDLIBS\@/$config{LDLIBS}/ if defined $config{LDLIBS};
			$tmp =~ s/\@BASE_DIR\@/$config{BASE_DIR}/ if defined $config{BASE_DIR};
			$tmp =~ s/\@CONFIG_DIR\@/$config{CONFIG_DIR}/ if defined $config{CONFIG_DIR};
			$tmp =~ s/\@MODULE_DIR\@/$config{MODULE_DIR}/ if defined $config{MODULE_DIR};
			$tmp =~ s/\@BINARY_DIR\@/$config{BINARY_DIR}/ if defined $config{BINARY_DIR};
			$tmp =~ s/\@LIBRARY_DIR\@/$config{LIBRARY_DIR}/ if defined $config{LIBRARY_DIR};
			$tmp =~ s/\@MODULES\@/$modules/ if defined $modules;
			$tmp =~ s/\@STARTSCRIPT\@/$config{STARTSCRIPT}/ if defined $config{STARTSCRIPT};
			$tmp =~ s/\@DESTINATION\@/$config{DESTINATION}/ if defined $config{DESTINATION};
			$tmp =~ s/\@EXTRA_DIR\@/$config{EXTRA_DIR}/ if defined $config{EXTRA_DIR};
			$tmp =~ s/\@EXECUTABLE\@/$exe/ if defined $exe;
			$tmp =~ s/\@MAKEORDER\@/$config{MAKEORDER}/ if defined $config{MAKEORDER};
			$tmp =~ s/\@VERSION\@/$version/ if defined $version;
			$tmp =~ s/\@INSTALL_LIST\@/$install_list/ if defined $install_list;
			$tmp =~ s/\@UNINSTALL_LIST\@/$uninstall_list/ if defined $uninstall_list;

			open(FILEHANDLE, ">$file");
			print FILEHANDLE $tmp;
		}
	}
	closedir(DIRHANDLE);

	# Make hottpd executable!
	chmod 0744, 'hottpd';
}

sub write_dynamic_modules_makefile {
	# Modules Makefile..
	print "Writing \e[1;32msrc/modules/Makefile\e[0m\n";
	open(FILEHANDLE, ">src/modules/Makefile");

###
# Module Makefile Header
###
	print FILEHANDLE <<EOF;
###################################################
# Copyright 2002-2007 The InspIRCd Development Team
#  http://www.inspircd.org/wiki/index.php/Credits
#
# Thanks to Andrew Church <achurch\@achurch.org>
#   for assisting with making this work right.
#
# Automatically Generated by ./configure to add a
#  modules please run ./configure -modupdate
###################################################

all: \$(MODULES)

EOF

if ($config{OSNAME} =~ /darwin/) {
		print FILEHANDLE <<EOCHEESE;

PICLDFLAGS = -twolevel_namespace -undefined dynamic_lookup -bundle

EOCHEESE
} else {
		print FILEHANDLE <<EOCHEESE;

PICLDFLAGS = -fPIC -DPIC -shared

EOCHEESE
}

	###
	# End Module Makefile Header
	###

	# Create a Modules List..
	my $modules = "";
	my $cmflags = "";
	my $liflags = "";
	foreach my $i (@modlist) {
		###
		# Write Entry to the MakeFile
		###
		$cmflags = getcompilerflags("src/modules/m_".$i.".cpp");
		$liflags = getlinkerflags("src/modules/m_".$i.".cpp");
		my $deps = getdependencies("src/modules/m_".$i.".cpp");
	
		#print "file: $i: cmflags=$cmflags; liflags=$liflags; deps=$deps\n";
	

		if (nopedantic("src/modules/m_".$i.".cpp"))
		{
			print FILEHANDLE "
m_$i.so: m_$i.cpp ../../include/modules.h ../../include/users.h ../../include/channels.h ../../include/base.h ../../include/inspircd_config.h ../../include/inspircd.h ../../include/configreader.h $deps
	\@../../make/run-cc.pl \$(CC) -pipe -I../../include \$(NICEFLAGS) $cmflags \$(PICLDFLAGS) $liflags -export-dynamic -o m_$i.so m_$i.cpp
"
		}
		else
		{
			print FILEHANDLE "
m_$i.so: m_$i.cpp ../../include/modules.h ../../include/users.h ../../include/channels.h ../../include/base.h ../../include/inspircd_config.h ../../include/inspircd.h ../../include/configreader.h $deps
	\@../../make/run-cc.pl \$(CC) -pipe -I../../include \$(FLAGS) $cmflags \$(PICLDFLAGS) $liflags -export-dynamic -o m_$i.so m_$i.cpp
";
		}
		$install_list = $install_list . "	install -m \$(INSTMODE) src/modules/m_$i.so \$(MODPATH)\n";
		$uninstall_list = $uninstall_list . "	-rm \$(MODULES)/m_$i.so\n";
###
		# End Write Entry to the MakeFile
		###
	}

	opendir(DIRHANDLE, "src/modules");
	foreach my $name (sort readdir(DIRHANDLE)) {
		if ($name =~ /^m_(.+?)$/) {
			$mfrules = "";
			$mobjs = "";
			$mliflags = "";
			$mfcount = 0;
			# A module made of multiple files, in a dir, e.g. src/modules/m_spanningtree/
			if (defined(opendir(MDIRHANDLE, "src/modules/$name"))) {
				read_module_directory("src/modules/$name", $name);
				print "Composing Makefile rules for directory \e[1;32m$name\e[0m... (\e[1;32m$mfcount files found\e[0m)\n";
				print FILEHANDLE "$name.so: ../../include/modules.h ../../include/users.h ../../include/channels.h ../../include/base.h ../../include/inspircd_config.h ../../include/inspircd.h ../../include/configreader.h $mobjs\n"; 
				if ($config{IS_DARWIN} eq "YES") {
					print FILEHANDLE "	\@../../make/run-cc.pl \$(CC) -pipe -twolevel_namespace -undefined dynamic_lookup \$(FLAGS) $mliflags -bundle -o $name.so $mobjs\n"; 
				} else {
					print FILEHANDLE "	\@../../make/run-cc.pl \$(CC) -pipe \$(FLAGS) -shared $mliflags -o $name.so $mobjs\n";
				}
				print FILEHANDLE "\n$mfrules\n";
				closedir(MDIRHANDLE);
				$install_list = $install_list . "	install -m \$(INSTMODE) src/modules/$name.so \$(MODPATH)\n";
			}
		}
	}
	closedir(DIRHANDLE);
}

sub read_module_directory {
	my ($dpath, $reldpath) = @_;
	
	if (opendir(MDIRHANDLE, $dpath) == 0) {
		return;
	}
	
	foreach my $fname (sort readdir(MDIRHANDLE)) {
		if ($fname =~ /\.cpp$/) {
			my $cmflags = getcompilerflags("$dpath/$fname");
			$mliflags = $mliflags . " " . getlinkerflags("$dpath/$fname");
			my $deps = getdependencies("$dpath/$fname");
			my $oname = $fname;
			$oname =~ s/\.cpp$/.o/g;
			$mfrules = $mfrules .  "$reldpath/$oname: $reldpath/$fname ../../include/modules.h ../../include/users.h ../../include/channels.h ../../include/base.h ../../include/inspircd_config.h ../../include/inspircd.h ../../include/configreader.h $deps\n";
			$mfrules = $mfrules .  "	\@../../make/run-cc.pl \$(CC) -pipe -I../../include -I. \$(FLAGS) $cmflags -export-dynamic -o $reldpath/$oname -c $reldpath/$fname\n\n";
			$mobjs = $mobjs . " $reldpath/$oname";
			$mfcount++;
		}
		elsif ((-d "$dpath/$fname") && !($fname eq ".") && !($fname eq "..")) {
			read_module_directory($dpath."/".$fname, $reldpath."/".$fname);
		}
	}
}

sub calcdeps($)
{
	# Yes i know we could use gcc -M but it seems to ideneify a lot of 'deep'
	# dependencies which are not relevent in C++.

	my $file = $_[0];

	open (CPP, "<$file") or die("Can't open $file for reading!");

	my %dupe = ();
	my $retlist = "";

	foreach my $d (@ignoredeps)
	{
		$dupe{$d} = 1;
	}

	my $immutable = "";
	foreach my $dep (@immutabledeps)
	{
		$immutable = $immutable . "../include/$dep ";
	}
	$immutable =~ s/ $//g;

	while (defined(my $line = <CPP>))
	{
		chomp($line);
		if ($line =~ /#include "(.+\.h)"/)
		{
			if (!exists($dupe{$1}))
			{
				$retlist = $retlist . "../include/$1 ";
				$dupe{$1} = 1;
			}
		}
	}
	close CPP;
	return length($immutable) ? $immutable . " " . $retlist : $retlist;
}

sub write_dynamic_makefile
{
	my $i = 0;
	my @cmdlist = ();
	my %existing_install_list = ();
	opendir(DIRHANDLE, "src/commands");
	foreach my $name (sort readdir(DIRHANDLE))
	{
		if ($name =~ /^cmd_(.+)\.cpp$/)
		{
			$cmdlist[$i++] = $1;
			$install_list = $install_list . "	-install -m \$(INSTMODE) src/commands/cmd_" . $1 . ".so \$(LIBPATH)\n";
			$uninstall_list = $uninstall_list . "	-rm \$(LIBPATH)/cmd_$1.so\n";
	    	}
	}
	closedir(DIRHANDLE);

	if (!$has_epoll)
	{
		$config{USE_EPOLL} = 0;
	}
	if (!$has_kqueue)
	{
		$config{USE_KQUEUE} = 0;
	}
	if (!$has_ports)
	{
		$config{USE_PORTS} = 0;
	}

	foreach my $dir (("src","src/commands","src/modes","src/socketengines","src/modules"))
	{
		print "Scanning \e[1;32m$dir\e[0m for core files ";
		opendir(DIRHANDLE, $dir);
		foreach my $name (sort readdir(DIRHANDLE))
		{
			if ($name =~ /\.cpp$/)
			{
				open (CPP, "<$dir/$name") or die("Can't open $dir/$name to scan it! oh bugger");
				print ".";
				while (defined(my $line = <CPP>))
				{
					chomp($line);
					if ($line =~ /\/\* \$Core: (\w+) \*\//i)
					{
						$filelist{$name} = $1;
					}
					elsif ($line =~ /\/\* \$ExtraDeps: (.*?) \*\//i)
					{
						$specialdeps{$name} = $1;
					}
					elsif ($line =~ /\/\* \$ExtraObjects: (.*?) \*\//i)
					{
						$extraobjects{$name} = $1;
					}
					elsif ($line =~ /\/\* \$ExtraBuild: (.*?) \*\//i)
					{
						$extrabuildlines{$name} = $1;
					}
					elsif ($line =~ /\/\* \$ExtraSources: (.*?) \*\//i)
					{
						$extrasources{$name} = $1;
						}
					elsif ($line =~ /\/\* \$If: (\w+) \*\//i)
					{
						if (defined $config{$1})
						{
							if (($config{$1} !~ /y/i) and ($config{$1} ne "1"))
							{
								# Skip to 'endif'
								while (defined($line = <CPP>))
								{
									chomp($line);
									die ("\$If buildsystem instruction within another \$If in file $dir/$name") if ($line =~ /\/\* \$If: (\w+) \*\//i);
									last if ($line =~ /\/\* \$EndIf \*\//i);
								}
							}
						}
					}
					elsif ($line =~ /\/\* \$Install: (.*?) \*\//i)
					{
						if (!exists($existing_install_list{$1}))
						{
							$existing_install_list{$1} = 1;
							my $idir = (split(' ',$1))[1];
							my $ifile = (split(' ',$1))[0];
							$install_list = $install_list . "	-install -m \$(INSTMODE) $1\n";
							$ifile =~ s/.*\///g;
							$uninstall_list = $uninstall_list . "	-rm $idir/$ifile\n";
						}
					}
					elsif ($line =~ /\/\* \$CopyInstall: (.*?) \*\//i)
					{
						if (!exists($existing_install_list{$1}))
						{
							$existing_install_list{$1} = 1;
							my $idir = (split(' ',$1))[1];
							my $ifile = (split(' ',$1))[0];
							$install_list = $install_list . "	-cp $1\n";
							$ifile =~ s/.*\///g;
							$uninstall_list = $uninstall_list . "	-rm $idir/$ifile\n";
						}
					}
				}
				close CPP;
			}
		}
		closedir(DIRHANDLE);
		print " done!\n";
	}

	my $freebsd4libs = (defined $config{CRAQ} ? $config{CRAQ} : "");

	my $all = "all: ";
	my $all_libsonly = "";
	my $libraryext = "";
	my $othercrap = "";
	my $RPATH = "";

	if ($config{IS_DARWIN} eq "YES")
	{
		$libraryext = "dylib";
		$othercrap = "	\@../make/run-cc.pl \$(CC) -pipe -I../include \$(FLAGS) -export-dynamic -c inspircd.cpp\n	\@../make/run-cc.pl \$(CC) -pipe -dynamic -bind_at_load -L. -o hottpd \$(LDLIBS) inspircd.o "
	}
	else
	{
		$libraryext = "so";
		$RPATH = "-Wl,--rpath -Wl,$config{LIBRARY_DIR}" unless defined $opt_disablerpath;
		$othercrap = "	\@../make/run-cc.pl \$(CC) -pipe -I../include $RPATH \$(FLAGS) $freebsd4libs -rdynamic -L. inspircd.cpp -o hottpd \$(LDLIBS) ";
	}

	foreach my $cpp (sort keys %filelist)
	{
		$all = $all . $filelist{$cpp} . "." . $libraryext . " ";
		$all_libsonly = $all_libsonly . $filelist{$cpp} . "." . $libraryext . " ";
		$install_list = $install_list . "	-install -m \$(INSTMODE) src/" . $filelist{$cpp} . "." . $libraryext . " \$(LIBPATH)\n";
		$uninstall_list = $uninstall_list . "	-rm \$(LIBPATH)/" . $filelist{$cpp} . "." . $libraryext . "\n";
	}
	$all = $all . "moo hottpd\n";

	$othercrap = $othercrap . " $all_libsonly\n\n";

	open(FH,">src/Makefile") or die("Could not write src/Makefile");
	print FH <<EOM;

CC = im a cheezeball
CXXFLAGS = -I../include \${FLAGS}
CPPFILES = \$(shell /bin/ls -l modes/ | grep '\\.cpp' | sed 's/^.* //' | grep -v svn)
RELCPPFILES = \$(shell /bin/ls -l modes/ | grep '\\.cpp' | sed 's/^.* /modes\\//' | grep -v svn)

EOM

	print FH "$all\n\n";

	my $deps = calcdeps("src/inspircd.cpp");
	print FH "inspircd: inspircd.cpp $deps $all_libsonly\n";
	print FH "$othercrap\n";

	foreach my $cpp (sort keys %filelist)
	{
		my $thislib = $filelist{$cpp} . "." . $libraryext; 
		my $objs = $cpp;
		my $rawcpp = $cpp;
		my $libcrap = "";
		$objs =~ s/\.cpp$/.o/;
		if (exists($extraobjects{$cpp}))
		{
			$objs = $objs . " " . $extraobjects{$cpp};
		}
		if (exists($extrasources{$cpp}))
		{
			$rawcpp = $rawcpp . " " . $extrasources{$cpp};
		}
		if ($config{IS_DARWIN} eq "YES")
		{
			$libcrap = "-install_name " . $config{LIBRARY_DIR} . "/" . $thislib . " -dynamiclib -twolevel_namespace -undefined dynamic_lookup";
		}
		else
		{
			if (defined $opt_disablerpath)
			{
				$libcrap = " -shared";
			}
			else
			{
				$libcrap = "-Wl,--rpath -Wl," . $config{LIBRARY_DIR} . " -shared";
			}
		}
		$deps = calcdeps("src/$cpp");
		if (exists($extrasources{$cpp}))
		{
			foreach my $seperate (sort split(' ',$extrasources{$cpp}))
			{
				my $d = calcdeps("src/$extrasources{$cpp}") . " ";
				if ($d ne "")
				{
					$deps = $deps . $d . " ";
				}
			}
		}
		print FH $thislib . ": $cpp $deps ". (defined($specialdeps{$cpp}) ? $specialdeps{$cpp} : "") . "\n";
		print FH "	\@../make/run-cc.pl \$(CC) -pipe -I../include \$(FLAGS) -export-dynamic -c $rawcpp\n";
		if (exists($extrabuildlines{$cpp}))
		{
			print FH "	" . $extrabuildlines{$cpp} . "\n";
		}
		print FH "	\@../make/run-cc.pl \$(CC) -pipe $libcrap -o " . $thislib . " " . $objs . "\n\n";
	}

	print FH "moo:\n	\@\${MAKE} -C \"commands\" DIRNAME=\"src/commands\" CC=\"\$(CC)\" \$(MAKEARGS)\n\n";

	# close main makefile
	close(FH);

	my $cmdobjs = "";
	# generate a list of .so
	foreach my $cmd (@cmdlist) {
		$cmdobjs = $cmdobjs . "cmd_$cmd.so ";
	}

	# and now reopen the commands makefile
	open(FH,">src/commands/Makefile") or die("Could not write src/commands/Makefile");
	print FH <<ITEM;
CC = i am cornholio
CXXFLAGS = -I../../include \${FLAGS}

all: $cmdobjs


ITEM

	# now print the command file details.
	foreach my $cmd (@cmdlist) {
		print FH <<ITEM;
cmd_$cmd.so: cmd_$cmd.cpp ../../include/base.h ../../include/modules.h ../../include/inspircd.h ../../include/channels.h ../../include/users.h ../../include/globals.h ../../include/inspircd_config.h ../../include/commands/cmd_$cmd.h
	\@../../make/run-cc.pl \$(CC) -pipe -I../../include \$(FLAGS) -export-dynamic $SHARED -o cmd_$cmd.so cmd_$cmd.cpp

ITEM
	}
}

# Routine to list out the extra/ modules that have been enabled.
# Note: when getting any filenames out and comparing, it's important to lc it if the
# file system is not case-sensitive (== Epoc, MacOS, OS/2 (incl DOS/DJGPP), VMS, Win32
# (incl NetWare, Symbian)). Cygwin may or may not be case-sensitive, depending on
# configuration, however, File::Spec does not currently tell us (it assumes Unix behavior).
sub list_extras () {
	use File::Spec;
	# @_ not used
	my $srcdir = File::Spec->catdir("src", "modules");
	my $abs_srcdir = File::Spec->rel2abs($srcdir);
	local $_;
	my $dd;
	opendir $dd, File::Spec->catdir($abs_srcdir, "extra") or die (File::Spec->catdir($abs_srcdir, "extra") . ": $!\n");
	my @extras = map { File::Spec->case_tolerant() ? lc($_) : $_ } (readdir($dd));
	closedir $dd;
	undef $dd;
	opendir $dd, $abs_srcdir or die "$abs_srcdir: $!\n";
	my @sources = map { File::Spec->case_tolerant() ? lc($_) : $_ } (readdir($dd));
	closedir $dd;
	undef $dd;
	my $maxlen = (sort { $b <=> $a } (map {length($_)} (@extras)))[0];
	my %extras = ();
EXTRA:	for my $extra (@extras) {
		next if (File::Spec->curdir() eq $extra || File::Spec->updir() eq $extra);
		next if ($extra eq '.svn');
		my $abs_extra = File::Spec->catfile($abs_srcdir, "extra", $extra);
		my $abs_source = File::Spec->catfile($abs_srcdir, $extra);
		next unless ($extra =~ m/\.(cpp|h)$/ || (-d $abs_extra)); # C++ Source/Header, or directory
		if (-l $abs_source) {
			# Symlink, is it in the right place?
			my $targ = readlink($abs_source);
			my $abs_targ = File::Spec->rel2abs($targ, $abs_srcdir);
			if ($abs_targ eq $abs_extra) {
				$extras{$extra} = "\e[32;1menabled\e[0m";
			} else {
				$extras{$extra} = sprintf("\e[31;1mwrong symlink target (%s)\e[0m", $abs_targ);
			}
		} elsif (-e $abs_source) {
			my ($devext, $inoext) = stat($abs_extra);
			my ($devsrc, $inosrc, undef, $lnksrc) = stat($abs_source);
			if ($lnksrc > 1) {
				if ($devsrc == $devext && $inosrc == $inoext) {
					$extras{$extra} = "\e[32;1menabled\e[0m";
				} else {
					$extras{$extra} = sprintf("\e[31;1mwrong hardlink target (%d:%d)\e[0m", $devsrc, $inosrc);
				}
			} else {
				open my $extfd, "<", $abs_extra;
				open my $srcfd, "<", $abs_source;
				local $/ = undef;
				if (scalar(<$extfd>) eq scalar(<$srcfd>)) {
					$extras{$extra} = "\e[32;1menabled\e[0m";
				} else {
					$extras{$extra} = sprintf("\e[31;1mout of synch (re-copy)\e[0m");
				}
			}
		} else {
			$extras{$extra} = "\e[33;1mdisabled\e[0m";
		}
	}
	# Now let's add dependency info
	for my $extra (keys(%extras)) {
		next unless $extras{$extra} =~ m/enabled/; # only process enabled extras.
		my $abs_extra = File::Spec->catfile($abs_srcdir, "extra", $extra);
		my @deps = split / +/, getdependencies($abs_extra);
		for my $dep (@deps) {
			if (exists($extras{$dep})) {
				my $ref = \$extras{$dep}; # Take reference.
				if ($$ref !~ m/needed by/) {
					# First dependency found.
					if ($$ref =~ m/enabled/) {
						$$ref .= " (needed by \e[32;1m$extra\e[0m";
					} else {
						$$ref =~ s/\e\[.*?m//g; # Strip out previous coloring. Will be set in bold+red+blink later.
						$$ref .= " (needed by \e[0;32;1;5m$extra\e[0;31;1;5m";
					}
				} else {
					if ($$ref =~ m/enabled/) {
						$$ref .= ", \e[32;1m$extra\e[0m";
					} else {
						$$ref .= ", \e[0;32;1;5m$extra\e[0;31;1;5m";
					}
				}
			}
		}
	}
	for my $extra (sort {$a cmp $b} keys(%extras)) {
		my $text = $extras{$extra};
		if ($text =~ m/needed by/ && $text !~ m/enabled/) {
			printf "\e[31;1;5m%-*s = %s%s\e[0m\n", $maxlen, $extra, $text, ($text =~ m/needed by/ ? ")" : "");
		} else {
			printf "%-*s = %s%s\n", $maxlen, $extra, $text, ($text =~ m/needed by/ ? "\e[0m)" : "");
		}
	}
	return keys(%extras) if wantarray; # Can be used by manage_extras.
}

sub enable_extras (@) {
	my (@extras) = @_;
	for my $extra (@extras) {
		my $extrapath = "src/modules/extra/$extra";
		if (!-e $extrapath) {
			print STDERR "Cannot enable \e[32;1m$extra\e[0m : No such file or directory in src/modules/extra\n";
			next;
		}
		my $source = "src/modules/$extra";
		if (-e $source) {
			print STDERR "Cannot enable \e[32;1m$extra\e[0m : destination in src/modules exists (might already be enabled?)\n";
			next;
		}
		# Get dependencies, and add them to be processed.
		my @deps = split / +/, getdependencies($extrapath);
		for my $dep (@deps) {
			next if scalar(grep { $_ eq $dep } (@extras)) > 0; # Skip if we're going to be enabling it anyway.
			if (!-e "src/modules/$dep") {
				if (-e "src/modules/extra/$dep") {
					print STDERR "Will also enable extra \e[32;1m$dep\e[0m (needed by \e[32;1m$extra\e[0m)\n";
					push @extras, $dep;
				} else {
					print STDERR "\e[33;1mWARNING:\e[0m module \e[32;1m$extra\e[0m might be missing dependency \e[32;1m$dep\e[0m - YOU are responsible for satisfying it!\n";
				}
			}
		}
		print "Enabling $extra ... \n";
		symlink "extra/$extra", $source or print STDERR "$source: Cannot link to 'extra/$extra': $!\n";
	}
}

sub disable_extras (@)
{
	opendir my $dd, "src/modules/extra/";
	my @files = readdir($dd);
	closedir $dd;
	my (@extras) = @_;
EXTRA:	for my $extra (@extras) {
		my $extrapath = "src/modules/extra/$extra";
		my $source = "src/modules/$extra";
		if (!-e $extrapath) {
			print STDERR "Cannot disable \e[32;1m$extra\e[0m : Is not an extra\n";
			next;
		}
		if ((! -l $source) || readlink($source) ne "extra/$extra") {
			print STDERR "Cannot disable \e[32;1m$extra\e[0m : Source is not a link or doesn't refer to the right file. Remove manually if this is in error.\n";
			next;
		}
		# Check if anything needs this.
		for my $file (@files) {
			my @deps = split / +/, getdependencies("src/modules/extra/$file");
			# File depends on this extra...
			if (scalar(grep { $_ eq $extra } @deps) > 0) {
				# And is both enabled and not about to be disabled.
				if (-e "src/modules/$file" && scalar(grep { $_ eq $file } @extras) < 1) {
					print STDERR "Cannot disable \e[32;1m$extra\e[0m : is needed by \e[32;1m$file\e[0m\n";
					next EXTRA;
				}
			}
		}
		# Now remove.
		print "Disabling $extra ... \n";
		unlink "src/modules/$extra" or print STDERR "Cannot disable \e[32;1m$extra\e[0m : $!\n";
	}
}

